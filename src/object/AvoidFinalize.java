package object;

/**
 * @program: Effective Java
 * @description: 避免使用终结方法
 * @author: 王志立
 * @create: 2018-12-26 14:23
 **/
public class AvoidFinalize {
  //todo 避免使用总结方法
  /* 1. 总结方法一般都是不可预测的，也是很危险的，一般情况下也是没有必要的，终结方法会导致行为不稳定，降低性能，以及可移植性问题
   * 2. 当一个对象变得不可到达的时候，垃圾回收器会回收该对象与该对象关联的储存空间，并不需要程序员的专门工作。
   * 3. 总结方法的缺点在于不能保证会被及时执行。从一个对象变得不可达开始，到他的终结方面被执行，所需要花费的时间是任意长的，用终结方法来关闭已经打开的文件，这是严重的错误
   * 4. 及时的执行终结方法正式垃圾回收算法的一个主要功能，这种算法在不同的JVM中会大相径庭。
   * 5. 延迟终结过程并不是一个理论问题，在很少的情况下，为类提供终结方法，可能会随意的延迟其实例的回收过程。
   * 6. Java语言规范并不保证那个线程将会执行终结方法，所以，除了不使用终结方法外，并没有办法解决大量对象需要被终结和回收的情况。
   * 7. Java语言规范不仅不保证终结方法会被及时执行，而且根本就不保证他们会被执行，所以，不应该依赖终结方法来更新重要的持久状态。
   * 8. 不能被System.gc()和 Runtime.getRuntime().gc()这样的两种方法诱惑，他们只是增加了终结方法执行的机会，但他们并不保证终结方法一定会执行。只是负责通知这里需要被GC
   * 9.  System.runFinalization()/Runtime.getRuntime().runFinalization() 强制要求执行，但这也是不可取的
   * 10. System.runFinalizersOnExit() /Runtime.runFinalizersOnExit()方法强制执行GC操作私有致命的缺陷的，已经被废弃。
   * 11. 正常情况下，未捕获的异常会使线程终止，并打印出出栈轨迹，但是异常发生在终结方法中，甚至连警告都不会答应出来
   * 12. 终结方法有一个严重的（Severe）性能损失，创建和销毁一个简单对象的方法的时间是几ns级别，增加一个终结方法令时间增加了430倍
   * 13. 对于对象中封装的资源，提供一个显示的终结方法，并在客户端在不使用这个实例的时候调用它
   * 14. 显示的终结方法一般跟try-finally结构联合使用，以确保及时终止
   * 15. 当对象的所有者忘记调用前面的显示终结方法时，终结方法可以充当安全网（迟一点释放资源，总比不释放的好）
   * 16. 本地对等体是一个本地对象，普通对象通过本地方法委托给一个本地对等体，因为本地对等体不是一个普通对象，所以垃圾回收机制不会知道他，终结方法才是终结他的最合适的工具
   * 17. 如果超类实现者覆盖了超类的终结方法，，但是忘了手动调用超类的终结方法那么超类的终结方法永远不会被调用到
   * 18. 除非是使用安全网，或者是为了终止非关键的本地资源，否则不要使用这种方法
   */

  public static void main(String[] args) {
       try{
           //执行操作
           System.out.println("执行操作");
       }catch (Exception e){
           //处理异常
           System.out.println("处理异常");
       }
       finally {
           System.out.println("回收资源");
       }

  }
}
